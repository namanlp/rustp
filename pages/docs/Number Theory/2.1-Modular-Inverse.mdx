---
title: Modular Multiplicative Inverse
section: 2.1 Arithmetic Operations
order: 3
slug: /number-theory/modular-inverse/
description: Hello
---

# Modular Multiplicative Inverse in Rust
And program in Rust to find it using Fermat's little theorem

## What is Modular Multiplicative Inverse

As we know that there is **no divide operation in Modular Arithmetic**. So, Modular Multiplicative Inverse is a number that *replaces* divide function  in Modular Arithmetic.
Modular Multiplicative Inverse of **n** with respect to **p** is a natural number **between 1 and p-1**, let us say x, such that

<center> <b> ( n × x )  mod p = 1 </b> </center>

We can alternatively say that Modular Multiplicative Inverse is a number such that **( n × x ) - 1 is divisible by p**.

x can also be written as **x = ( n<sup>-1</sup> ) mod p**

**For Example :** Modular Multiplicative Inverse of 23 with respect to 10 is 7. ( Because 23 × 7 = 161 and 161 % 10 = 1 )

<hr />

**Note :** The multiplicative inverse of  **n** with respect to **p** exists if and only if **n and p are co prime numbers**

**Proof :** Let us suppose n = q × p + r , where q is quotient and r is remainder. So, if n is divisible by gcd, and p is divisible by gcd, then r must be divisible by gcd too. ( From Euclidean Algorithm )

Hence, if gcd > 1, then remainder must also be greater than 1.

## Need of Modular Multiplicative Inverse

1. For returning or printing fractional numbers in competitive programming. For example, we have to find ( p / q ) mod m. It is simply written as (p × q<sup>-1</sup>) mod m or ( (p mod) ×  (q<sup>-1</sup>) mod m ) mod m,
where **( q<sup>-1</sup> ) mod m** is Modular Multiplicative Inverse of q with respect to m.


2. To find Permutation and Combination of very large numbers. For example, we have to find <sup>100</sup>P<sub>50</sub>. We must first [generate factorial array](/number-theory/factorial-of-mutiple-numbers/),
then compute Modular Multiplicative Inverse of 50! with respect to given number, and multiply it with 100! mod p, and then compute answer. We will discuss detailed method later.


3. In Cryptography, especially in RSA algorithm.

## Naive Approach

Simplest brute force solution can be to simply traverse all numbers from 1 to p-1, and return the number if ( n × x  ) % p = 1  or ( n × x ) - 1 is divisible by p.

Function using this approach

```rust
fn mod_inverse (n:i128, p:i128) -> i128{
    // Checks numbers from 1 to p-1
    for x in 1..p {
        if (n*x) % p == 1 {
            return x;
        }
    }

    // Returns 0 if no Modular Multiplicative Inverse exist
    return 0;
}
```

With Driver Code

```rust
use std::io::stdin;

fn take_int() -> i128 {
    let mut input = String::new();
    stdin().read_line(&mut input).unwrap();
    input.trim().parse().unwrap()
}

// Magic starts here

fn mod_inverse (n:i128, p:i128) -> i128{
    // Checks numbers from 1 to p-1
    for x in 1..p {
        if (n*x) % p == 1 {
            return x;
        }
    }

    // Returns 0 if no Modular Multiplicative Inverse exist
    return 0;
}

// Driver Code

pub fn main() {
    let n = take_int();
    let p = take_int();

    println!("{}", mod_inverse(n, p));
}
```

**Input**
>213 <br />
1000000007 <br />

**Output**
>32863850

**Time Complexity : O( p )** <br/>
**Space Complexity : O( 1 )**
<br />