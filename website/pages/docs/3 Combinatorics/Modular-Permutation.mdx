---
title: Modular Permutation
section: 3 Combinatorics
order: 11
slug: /combinatorics/modular-permutation/
description: Modular Permutation
---

# Modular Permutation
and program to find the Modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust

## Introduction

In many problems, it becomes unfeasible to calculate Permutation using traditional data types like `i64` or even `i128` due to `overflow`. The largest integer data type in rust, `u128` can hold the number upto order of 10<sup>38</sup>.
But Permutations grows pretty fast with n and r. For example, **<sup>100</sup>P<sub>100</sub>** is approximately is 9.33 Ã— 10<sup>157</sup>

So, it becomes unfeasible from competitive programming point of view to compute exact values using C / C++ / Rust etc.
So, in most programming contest, we have to find the answer modulo with respect to given number, generally **<code>10<sup>9</sup> + 7 or 1000000007</code>** is used because It is *safe prime number*.

Hence, we will discuss how to find **Modular Permutation** or permutation of a large number with respect to a given number using [Modular factorial Array](/combinatorics/modular-factorial-array/) and [Modular Multiplicative inverse](/number-theory/modular-inverse/) in Rust.

## Naive Approach

The basic naive approach can be just finding the modular permutation by using modular multiplication and multiplying numbers from `n-r+1` to `n`, inclusive.

Here is code for above implementation.

```rust
fn modular_permutation(n: i128, r: i128, p:i128) -> i128{

    let mut ans = 1;

    for i in (n-r+1)..(n+1) {
        ans *= i;
        if ans>=p {
            ans = ans%p;
        }
    }

    ans%=p;
    return ans;
}
```
