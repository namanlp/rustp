---
title: Modular Permutation
section: 3 Combinatorics
order: 11
slug: /combinatorics/modular-permutation/
description: Modular Permutation
---

# Modular Permutation
and program to find the Modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust

## Introduction

In many problems, it becomes unfeasible to calculate Permutation using traditional data types like `i64` or even `i128` due to `overflow`. The largest integer data type in rust, `u128` can hold the number upto order of 10<sup>38</sup>.
But Permutations grows pretty fast with n and r. For example, **<sup>100</sup>P<sub>100</sub>** is approximately is 9.33 Ã— 10<sup>157</sup>

So, it becomes unfeasible from competitive programming point of view to compute exact values using C / C++ / Rust etc.
So, in most programming contest, we have to find the answer modulo with respect to given number, generally **<code>10<sup>9</sup> + 7 or 1000000007</code>** is used because It is *safe prime number*.

Hence, we will discuss how to find **Modular Permutation** or permutation of a large number with respect to a given number using [Modular factorial Array](/combinatorics/modular-factorial-array/) and [Modular Multiplicative inverse](/number-theory/modular-inverse/) in Rust.

## Single Permutation

When we have to find the value of 1 <sup>n</sup>P<sub>r</sub>, we can just find the modular permutation by using modular multiplication and multiplying numbers from `n-r+1` to `n`, inclusive.

Here is code for above implementation.

```rust
fn modular_permutation(n: i128, r: i128, p:i128) -> i128{

    let mut ans = 1;

    for i in (n-r+1)..(n+1) {
        ans *= i;
        if ans>=p {
            ans = ans%p;
        }
    }

    ans%=p;
    return ans;
}
```

With Driver Code

```rust

fn modular_permutation(n: i128, r: i128, p:i128) -> i128{

    let mut ans = 1;

    for i in (n-r+1)..(n+1) {
        ans *= i;
        if ans>=p {
            ans = ans%p;
        }
    }

    ans%=p;
    return ans;
}

// Driver code

use std::io::stdin;
fn take_int() -> i128 {
    let mut input = String::new();
    stdin().read_line(&mut input).unwrap();
    return input.trim().parse().unwrap();
}

pub fn main() {
    let n = take_int();
    let r = take_int();
    let p = take_int();
    println!("{}", modular_permutation(n, r, p));
}
```
**Input**
>100 <br/>
50 <br/>
1000000007


**Output**
>505671657

**Time Complexity : O( n )** <br/>
**Space Complexity : O( 1 )**

## Efficient Approach

When we have to find large number of modular permutations, say 10<sup>5</sup> or 10<sup>6</sup> permutations and n can also range up to 10<sup>5</sup> or 10<sup>6</sup>, we can clearly see that above approach will result into
TLE (Time Limit Exceeded) in Competitive Programming contests.

So, we have to find Modular Permutation in Constant time for each test case.

The idea is to first generate a [Modular Factorial Array](/combinatorics/modular-factorial-array/) and then generate 1 more array ,
containing [Modular Multiplicative Inverse](/number-theory/modular-inverse/) of all numbers, with respect to given number.

Then we can use equation

(<sup>n</sup> P <sub>r</sub>) mod p = ((n!)  mod p * (n-r)! <sup>-1</sup> mod p) mod p
