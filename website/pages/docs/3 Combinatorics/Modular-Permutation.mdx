---
title: Modular Permutation
section: 3 Combinatorics
order: 11
slug: /combinatorics/modular-permutation/
description: Modular Permutation
---

# Modular Permutation
and program to find the Modular Permutation using Modular factorial Array and Modular Multiplicative inverse in Rust

## Introduction

In many problems, it becomes unfeasible to calculate Permutation using traditional data types like `i64` or even `i128` due to `overflow`. The largest integer data type in rust, `u128` can hold the number upto order of 10<sup>38</sup>.
But Permutations grows pretty fast with n and r. For example, **<sup>100</sup>P<sub>100</sub>** is approximately is 9.33 × 10<sup>157</sup>

So, it becomes unfeasible from competitive programming point of view to compute exact values using C / C++ / Rust etc.
So, in most programming contest, we have to find the answer modulo with respect to given number, generally **<code>10<sup>9</sup> + 7 or 1000000007</code>** is used because It is *safe prime number*.

Hence, we will discuss how to find **Modular Permutation** or permutation of a large number with respect to a given number using [Modular factorial Array](/combinatorics/modular-factorial-array/) and [Modular Multiplicative inverse](/number-theory/modular-inverse/) in Rust.

## Single Permutation

When we have to find the value of 1 <sup>n</sup>P<sub>r</sub>, we can just find the modular permutation by using modular multiplication and multiplying numbers from `n-r+1` to `n`, inclusive.

**Note:** This would take linear time complexity for each permutation.

Here is code for above implementation.

```rust
fn modular_permutation(n: i128, r: i128, p:i128) -> i128{
    // Take Answer to be 1
    let mut ans = 1;

    // nPr = n! / (n-r)! = (n-r+1) × (n-r+2) × .... × n
    for i in (n-r+1)..(n+1) {
        ans *= i;

        // Division and Modulo are expensive for cpu
        // So, we find modulo if answer is greater than or equal to p
        // It can never become p though, else, answer will become 0
        if ans>=p {
            ans = ans%p;
        }
    }

    return ans;
}
```

With Driver Code

```rust

fn modular_permutation(n: i128, r: i128, p:i128) -> i128{
    // Take Answer to be 1
    let mut ans = 1;

    // nPr = n! / (n-r)! = (n-r+1) × (n-r+2) × .... × n
    for i in (n-r+1)..(n+1) {
        ans *= i;

        // Division and Modulo are expensive for cpu
        // So, we find modulo if answer is greater than or equal to p
        // It can never become p though, else, answer will become 0
        if ans>=p {
            ans = ans%p;
        }
    }

    return ans;
}

// Driver code

use std::io::stdin;
fn take_int() -> i128 {
    let mut input = String::new();
    stdin().read_line(&mut input).unwrap();
    return input.trim().parse().unwrap();
}

pub fn main() {
    // Take values of n, r and p
    let n = take_int();
    let r = take_int();
    let p = take_int();
    println!("{}", modular_permutation(n, r, p));
}

```
**Input**
>100 <br/>
50 <br/>
1000000007


**Output**
>505671657

**Time Complexity : O( n )** <br/>
**Space Complexity : O( 1 )**

## Efficient Approach

When we have to find large number of modular permutations, say 10<sup>5</sup> or 10<sup>6</sup> permutations and n can also range up to 10<sup>5</sup> or 10<sup>6</sup>, we can clearly see that above approach will result into
TLE (Time Limit Exceeded) in Competitive Programming contests.

So, we have to find Modular Permutation in Constant time for each test case.

The idea is to first generate a [Modular Factorial Array](/combinatorics/modular-factorial-array/) and then find the number of permutations using equation

<sup>n</sup>P<sub>r</sub> = n! / (n-r)!

Using Modular Arithmetic, this equation becomes

(<sup>n</sup> P <sub>r</sub>) mod p = ((n!)  mod p * (n-r)! <sup>-1</sup> mod p) mod p

To find the number of permutations.

