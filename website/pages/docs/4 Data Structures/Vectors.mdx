---
title: Vectors
section: 4 Data Structures
order: 2
slug: /data-structures/vectors
description: Vectors are array like contiguous growable storage with a lot more functionalities. We will see vectors and their default methods in Rust.
---

# Vectors
and the default vector functions in Rust

## Introduction

From [Rust standard library documentation On Vectors](https://doc.rust-lang.org/std/vec/struct.Vec.html), we define vectors as *contiguous growable array type*.
They are represented as `Vec<T>` , where the vector contains multiple instances of type **`T`**.
**`T`** can be any data type, like `usize`, `i128` or other class / structs, for example `Hashmap<usize, usize>` or another Vector, like `Vec<usize>` etc.

Now, as you might have noticed, Vectors are **contiguous as well as growable**, so how is that possible? The answer is concept of capacity and size.

## Capacity and Size

Actually, Rust vectors are allocated more memory than needed at the time of allocation. As soon as we need more memory, the complete array is copied to another location, and it is reallocated more memory.

So, for example, you create a Vector of 5 instances, using `vec![0;5]`. Rust will initially allocate capacity of 5 instances (`i32` in this case). Now, if you push any object, a new chunk of memory will be allocated for the vector.
Each time the allocated space becomes full, **Double memory space is allocated**. So in above example, a vector with capacity to hold 10 instances will be created.

However, the size or length of above vector will remain 6 itself, although the vector can now hold upto 10 instances. Let us see a code for better clarity.


```rust
fn main() {
    // Create a vector of length 5, with all elements as 0
    let mut vecky = vec![0; 5];

    // Print Size and capacity
    println!("Before adding element, size is {} and capacity is {}", vecky.len(), vecky.capacity());

    // Push 1 more 0
    vecky.push(0);

    // Print Size and capacity
    println!("After adding element, size is {} and capacity is {}", vecky.len(), vecky.capacity());
}
```

**Output**

> Before adding element, size is 5 and capacity is 5 <br />
After adding element, size is 6 and capacity is 10

## Creating a vector

**Vector** module ( std::vec::Vec ) is part of standard crate, and it is included in Rust **Prelude**, that means you don't have to include  std::vec::Vec explicitly for using vectors.

So, let's get started by creating a vector.


### Vec::new()

The `Vec::new()` method is used to initialize an empty vector, that is, with **0 size and capacity.** You don't have to specify the type of vector, because Rust will automatically determine the type, when you push any element into it.

You should use it when you just want a vector, and don't have any information about it, like capacity, size etc.

Here is sample declaration

```rust
let mut vecky = Vec::new();
```

<br />

### Vec::with_capacity()

The `Vec::with_capacity()` method is the best method to initialize a vector when you have an idea how many elements will it contain and the type of elements stored, but don't know all the elements beforehand.

This is my *personal preference* to use in any competitive programming contest, because it is simply most efficient, because most of the time, the size of array and type of elements will already be provided in the testcase.

So, the allocator doesn't have to reallocate again and again. Also, it doesn't initialize the elements, making it more efficient the `vec![]` macro.

Therefore, it is perhaps the most efficient way of creating dynamic vectors, when you have rough idea about how many elements will be stored in the vector and know the type of elements while initializing.

```rust
let mut vecky: Vec<usize> = Vec::with_capacity(5);
```

<br />
