---
title: Kadane’s Algorithm
section: 5.1 Array Algorithms
order: 1
slug: /array-algorithms/kadane-algorithm/
description: Largest Sum of a subarray
---

# Maximum Subarray Sum
in an array using Kadane’s Algorithm in Rust

## Problem Statement

Given an array of numbers, say **arr[]**, containing both **positive and negative elements**, you have to find the largest sum of the subarray of **arr[]**.

Subarray is defined as **contiguous** part of the original array, containing one or more element. For example, for array [1, 2, 3], [1, 2] is subarray while [1, 3] is not.

We have to find the largest  sum of all the subarray present in the given arr[].

import kadane from "../../../../images/Algorithms/Kadane.webp"

<div style={{textAlign: 'center'}} >
    <img src={kadane} width="100%" alt="Maximum Subarray Sum" />
</div>

## Naive Approach

Naive or brute force approach is to find the sum of all the subarray and return the maximum of them. Function using this approach is

```rust
fn max_subarray_sum(arr : Vec<i128>) -> i128{

    // it is not initialized to 0 because array can be all negative elements.
    let mut max_sum = arr[0];

    // Traverse through all the subarray
    for i in 0..arr.len() {

        // We use from i+1 to N inclusive
        // Because j is ending range of the slice.
        for j in i+1..arr.len()+1 {

            // We find the sum of the subarray [i..j]
            let mut sum = 0;
            for k in i..j {
                sum+=arr[k];
            }

            // Now compare the sum of this subarray with the max_sum
            if max_sum < sum {
                max_sum = sum;
            }
        }
    }

    return max_sum;
}
```

With driver code

```rust
fn max_subarray_sum(arr : Vec<i128>) -> i128{

    // it is not initialized to 0 because array can be all negative elements.
    let mut max_sum = arr[0];

    // Traverse through all the subarray
    for i in 0..arr.len() {

        // We use from i+1 to N inclusive
        // Because j is ending range of the slice.
        for j in i+1..arr.len()+1 {

            // We find the sum of the subarray [i..j]
            let mut sum = 0;
            for k in i..j {
                sum+=arr[k];
            }

            // Now compare the sum of this subarray with the max_sum
            if max_sum < sum {
                max_sum = sum;
            }
        }
    }

    return max_sum;
}

// Driver Code

fn main() {
    let arr:Vec<i128> = vec![4, -5, 3, -2, 1, 5, -6, 3];
    println!("{}", max_subarray_sum(arr));
}

```

**Output**

> 7

**Time Complexity : O( n<sup>3</sup> )** <br/>
**Space Complexity : O( 1 )**
