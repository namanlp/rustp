---
title: Range Query Segment Tree
section: 5.1 Array Algorithms
order: 3
slug: /array-algorithms/range-query-segment-tree/
description: Range Query Segment Tree
---

# Range Query in Segment Tree
and program to perform Range Query in a Segment Tree in Rust

## Introduction

I have already discussed the use cases as well as how to [Construct the  Segment Tree in Rust Language](/array-algorithms/construct-segment-tree/).
If you have not already read that article, please visit that before, because this is continuation of that article.

Here, we will actually perform Range Query on a segment tree to find output of a given subarray of an Array.

## Approach

Now, if we look at our Segment Tree and Range Queries carefully, we can categorize them in one of 3 categories.

1. **No Overlap :** In this, the Range of our Query and Given Node does not contain any common element. So, we return identity element in this case.
2. **Total Overlap :** In this, all the elements of the **given node** are covered in the query. In this, we simply return the value of node.
3. **Partial Overlap :** In this, there exists some elements that are covered in a node, but not in the query. In this, we have to search in its children nodes recursively.

**For example :** If a node contains value from [2, 5] (inclusive)

1. **No Overlap :** Will contain range query such as [0, 1], [6, 7] etc.
2. **Total Overlap :** Will contain range query such [1, 7] , [2, 10] etc.
3. **Partial Overlap :** Will contain range query such [3, 7] , [2, 3] etc.

## Function

```rust
fn range_query(st:&Vec<usize>, nl:usize, nh:usize, ql:usize, qh:usize, pos : usize) -> usize{
    //nl, nh == node low and node high respectively
    // ql, qh == query low and query high respectively

    // No Overlap, identity element in product is 1
    if nh < ql || qh < nl {
        return 1;
    }

    // Total overlap, return element at given node
    if nh<= qh && nl>=ql {
        return st[pos]
    }

    let mid = (h+l)/2;
    return range_query(st, nl, mid, ql, qh, 2*pos + 1) * range_query(st, mid+1, nh, ql, qh, 2*pos + 1);
}
```