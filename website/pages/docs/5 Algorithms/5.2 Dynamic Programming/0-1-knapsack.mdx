---
title: 0/1 Knapsack
section: 5.2 Dynamic Programming
order: 1
slug: /dynamic-programming/0-1-knapsack/
description: 0 1 Knapsack.
---

# 0/1 Knapsack Problem
and Dynamic Programming Solution to it using tabulation and memoization in Rust Language.

## Introduction

0/1 Knapsack Problem is also a classical Dynamic Programming problem. In this problem, you are a thief :D

So, in 0/1 knapsack problem, you are given a list of items, along with their weights and profits if you sell them. But you have a limited capacity knapsack, say **W**, that you can use to carry the items with you.

Also, you have whole items, that is, either you can take the item or leave it and you can take 1 item only once.

You have to tell the maximum profit you can earn by stealing the items.

**For Example**

Item Weight = [1, 4, 5, 7]

Profits = [3, 6, 9, 11]

And **W** = 11

Answer should be 18, ( Taking items weights [1, 4, 5])

## Recursive Solution

The recursive solution is pretty simple. We can either include a given item in knapsack, or do not include it.

So, we simply check all the possibilities, and return the maximum profit that we can obtain. We use the given algorithm.

### Algorithm

1. If the remaining weight in knapsack is less than the weight of given item, we can not carry it. Hence, check the other items.
2. We first try to include the item in the knapsack, and check the profit of remaining items with remaining weights recursively.
3. Then we exclude the item and check profit of remaining items and weight recursively.
4. We return the maximum profit earned through both the methods as the answer.

### Function

Here is the function using above algorithm

```rust

use std::cmp::max;

fn knapsack(w:usize, weights:&Vec<usize>, profits:&Vec<usize>, n:usize) -> usize{

    // If we have 0 elements remaining or knapsack filled, return 0
    if n==0 || w == 0 {
        return 0;
    }

    // If the nth element has higher weight than available capacity,
    // it can not be carried. So, return without including item
    if weights[n-1] > w {
        return knapsack(w, weights, profits, n-1);
    }

    // Else, we check by including and excluding the given item
    // And return max of it
    return max(
        // If we exclude item, simply return function for n-1 items
        knapsack(w, weights, profits, n-1),

        // If we include item, return profit of given item +
        // maximum value from given weight for remaining items
        profits[n-1] + knapsack(w-weights[n-1], weights, profits, n-1));
}
```

**Input**

> 1 4 5 7 <br />
3 6 9 11 <br />
11

**Output**

> 18


**Time Complexity : O( 2<sup>n</sup> )** <br/>
**Space Complexity : O( n )**

( Space complexity includes recursive stack space )


## Overlapping Sub-problems

If we have a look carefully on recursive approach, we computed multiple results many times.

**For Example :** If weights are [1, 2, 3, 4, 5, 6, 7, 8] and **W** = 20,

We have to compute best answer for n = 2, and W = 5 multiple times, for example, if we select [8, 7] , [8, 4, 3], [7, 5, 3], [6, 5, 4] etc.
And it takes 4 recursions each time, when we include and exclude 2 and 1. If we store it in a matrix, we do not have to calculate it again and again.

These are called **Overlapping Sub-problems** because they are smaller part of large problems, and are computed again and again.

So, we simply calculate them once, and store it in a matrix, and retrieve it when necessary.

This is called Dynamic Programming Approach for the problem.

