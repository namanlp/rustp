---
title: Longest Increasing Subsequence
section: 5.2 Dynamic Programming
order: 11
slug: /dynamic-programming/longest-increasing-subsequence/
description: Longest Increasing Subsequence
---

# Longest Increasing Subsequence
and Dynamic Programming Solution to it using memoization and tabulation in Rust Language.

## Introduction

Longest Increasing Subsequence is another classical Dynamic Programming problem, in which we have to find the length of longest increasing subsequence in a given array.

Subsequence of an array is defined as an array, that is formed by removing 0 or more elements from the original array.

**For Example :** If array are [1, 5, 8, 2, 4, 5, 10], the longest increasing subsequence is [1, 2, 4, 5, 10].

## Recursive Solution

Recursive solution to this problem is pretty straightforward. At each step, you have 2 choices :

1. **Include the element :** Include the given element, only if the previous element is lesser.
2. **Exclude the element :** We can exclude it and include other elements.

And recursively call for next elements.
We have to take maximum of both the cases.

### Function

Here is the function using above algorithm

```rust
use std::cmp::max;

fn lis_recursive(arr : &Vec<usize>, n:usize, i:usize, prev_index:Option<usize>) -> usize{
    // If completely traversed array, return 0
    if i >= n { return 0; }

    // If prev index is none, we can both include and exclude
    // Else, we can include iff previous element is lesser
    // So, we have to exclude otherwise

    if prev_index.is_some() && arr[i] <= arr[prev_index.unwrap()] {
        return lis_recursive( arr, n, i+1, prev_index);
    }

    // Else, we can both include and exclude,
    // So return max of both cases
    return max(
        1+lis_recursive(arr, n, i+1, Option::from(i)), // Include
        lis_recursive(arr, n, i+1, prev_index)); // Exclude
}
```

With Driver code

```rust
use std::cmp::max;

fn lis_recursive(arr : &Vec<usize>, n:usize, i:usize, prev_index:Option<usize>) -> usize{
    // If completely traversed array, return 0
    if i >= n { return 0; }

    // If prev index is none, we can both include and exclude
    // Else, we can include iff previous element is lesser
    // So, we have to exclude otherwise

    if prev_index.is_some() && arr[i] <= arr[prev_index.unwrap()] {
        return lis_recursive( arr, n, i+1, prev_index);
    }

    // Else, we can both include and exclude,
    // So return max of both cases
    return max(
        1+lis_recursive(arr, n, i+1, Option::from(i)), // Include
        lis_recursive(arr, n, i+1, prev_index)); // Exclude
}

// Driver Code

use std::io;
fn take_vector() -> Vec<usize> {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let arr: Vec<usize> = input.trim().split_whitespace()
        .map(|x| x.parse().unwrap()).collect();
    return arr;
}

fn main() {
    let arr = take_vector();
    println!("{}", lis_recursive(&arr, arr.len(), 0, None));
}
```

**Input**
> 1 5 8 2 4 5 10

**Output**

> 5

**Time Complexity : O( 2<sup>n</sup> )** <br/>
**Space Complexity : O( n )**

( Space complexity includes recursive stack space )

