---
title: Array Description
section: 5.2 Dynamic Programming
order: 25
slug: /dynamic-programming/array-description/
description: Array Description
---

# Array Description
and Dynamic Programming Solution to it using memoization and tabulation in Rust Language.

## Introduction

Array Description is another Dynamic Programming Problem taken from CSES problem set. Here is <a href="https://cses.fi/problemset/task/1746"> Array Description Problem Link </a>

In this question you are given an array with missing values and some conditions. You have to determine the number of possible arrays following those conditions.

**Conditions are :**

1. Absolute difference between two adjacent values is at most 1.
2. Each element in the array must be in range 1 to m ().

You are given the value of n, m and the array, in which missing numbers are represented by `0`, and other numbers are between 1 and m.

You have to tell the number of possible arrays that follow the above conditions. Since the answer may be very large, you have to tell the answer modulo 10<sup>9 </sup>+7

**For Example :** If the array is [2, 1, 0] and the m is 100, the answer will be 2 as the arrays can be [2, 1, 1] and [2, 1, 2].

## Recursive Solution

In the solution to this problem, we apply an observation.

**Observation :** If the value of the last element of the array is fixed, say `x`,  there can be only three values of last second element, that is `x-1`, `x` and `x+1`. Similarly, we can count the cases of last third element and so on till we reach first element.

We can apply this observation to solve this problem.

### Algorithm

If the last element of array is `0`, count the cases for all values of last element from 1 to m. Here is the function to count possible arrays.

Function takes the original array, index to check, m and value to check as input and return the number of possible cases for the array.

1. If the value to check is not in range of 1 to m, return 0.
2. If the given index of array is non 0, and not equal to the given value, return 0, because can not be possible.
3. Now, it is certainly possible to create an array using these values.
4. **Base Case :** If the index is 0, return 1, because we can set the first element to given value. Hence 1 case.
5. **Recursive Case :** Else, return the cases by setting previous element to given `value-1`, `value` and `value+1`.


### Function

Here is the function using above algorithm

```rust

fn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize) -> usize{

    // If value is not between 1 and m, no possible case
    if value >m || value < 1 { return 0; }

    // Now, if the array's given index value is already non 0
    // And not equal to the checked value, no possible case
    if arr[index] != 0 && arr[index] != value { return 0; }

    // Now, in either case, we can set the given value to the given index.
    // Hence, count the cases after setting given index to value

    // Base Case, if the first element is to be checked, return 1
    // Because if arr[0] == 0, only 1 possible case, that is set the value
    // Or if arr[0] == value, still only 1 case
    if index == 0 { return 1; }


    // Now cases are counted by recursively calling the function
    // For index -1, and values x-1, x, x+1
    // It is guaranteed that the value returned by each function
    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7

    return (count_arrays(arr, index-1, m, value-1) +
        count_arrays(arr, index-1, m, value) +
        count_arrays(arr, index-1, m, value+1)) % 1_000_000_007;
}
```

With Driver code

```rust


fn count_arrays(arr:&Vec<usize>, index:usize, m:usize, value:usize) -> usize{

    // If value is not between 1 and m, no possible case
    if value >m || value < 1 { return 0; }

    // Now, if the array's given index value is already non 0
    // And not equal to the checked value, no possible case
    if arr[index] != 0 && arr[index] != value { return 0; }

    // Now, in either case, we can set the given value to the given index.
    // Hence, count the cases after setting given index to value

    // Base Case, if the first element is to be checked, return 1
    // Because if arr[0] == 0, only 1 possible case, that is set the value
    // Or if arr[0] == value, still only 1 case
    if index == 0 { return 1; }


    // Now cases are counted by recursively calling the function
    // For index -1, and values x-1, x, x+1
    // It is guaranteed that the value returned by each function
    // is not greater than 10^9+7. So, we add them and return their modulo 10^9+7

    return (count_arrays(arr, index-1, m, value-1) +
        count_arrays(arr, index-1, m, value) +
        count_arrays(arr, index-1, m, value+1)) % 1_000_000_007;
}

// Driver code

// Take array input
use std::io;
fn take_vector() -> Vec<usize> {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let arr: Vec<usize> = input.trim().split_whitespace()
        .map(|x| x.parse().unwrap()).collect();
    return arr;
}

fn main() {
    // Input n and m
    let n_m = take_vector();
    let n = n_m[0];
    let m = n_m[1];

    // Take array
    let arr = take_vector();

    // Take sum of all the possible values.
    // Now, we know that usize can easily store numbers upto 10^18
    // So, we take modulo at the end.

    let mut ans = 0;

    // We take all possible value of last element.
    // If last element is non zero, other values will be rejected
    for i in 1..m+1 {
        ans+=count_arrays(&arr, n-1, m, i);
    }

    println!("{}", ans% 1_000_000_007);
}
```

**Input**
3 100
2 1 0

**Output**

> 2

**Time Complexity : O( 3<sup>n</sup> )** <br/>
**Space Complexity : O( n )**

( Space complexity includes recursive stack space )


## Overlapping Sub-problems

If we have a look carefully on recursive approach, we computed multiple results many times.

**For example :**  If `m` = 100 and array is [0, 0, 0, 0, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0, 0], we can reach the element 50 in thousands of ways, and takes thousands of recursions each time to calculate.

These are called **Overlapping Sub-problems** because they are smaller part of large problems, and are computed again and again.

So, we simply calculate them once, and store them in a matrix, and retrieve them when necessary. This helps to save a lot of computation.

This is called Memoization Dynamic Programming Approach for the problem.
