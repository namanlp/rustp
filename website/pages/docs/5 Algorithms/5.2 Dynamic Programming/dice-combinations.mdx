---
title: Dice Combinations
section: 5.2 Dynamic Programming
order: 7
slug: /dynamic-programming/dice-combinations/
description: Dice Combinations Solution
---

# Dice Combinations Problem
and Dynamic Programming Solution using tabulation and memoization in Rust Language.

## Introduction

The Dice Combinations is a very similar problem to to [Coin Change Problem](/dynamic-programming/coin-change/) , except that in this problem, the order of the selection also matters.

For example, in this problem, `1,2` and `2,1` is counted as different unlike Coin change problem.

So, in this problem, we have to find number of ways we can form a sum rolling dice any number of times.

**For Example :** If sum is 3, there are 4 ways to make it

* 1+1+1
* 1+2
* 2+1
* 3

Hence, the output should be **4**.


This problem has been taken from our beloved [CSES DP problem set. See Dice Combinations](https://cses.fi/problemset/task/1633)

## Recursive Solution

In the Recursive Solution to this problem, we have to make an observation.

If we fix the first number that comes on the dice, we can calculate the number of ways by subtracting it from n and calculating recursively.

For example, if we have to find the number of ways for **n = 7**, then we can fix first roll as 1, 2, 3, 4, 5 and 6 and then calculate the answer recursively.

To Summarize approach,

- **Base Case :** If the amount is less than or equal to 6, return corresponding value ( we already manually compute and store those values in an array )
- **Recursive Case :** Return the sum of recursively calculating answer for n-1, n-2, n-3, n-4, n-5 and n-6.

### Function

Here is the function using above algorithm

```rust
fn dice_combinations(amount :usize) -> usize{
    // We can make 0 in 1 and only 1 way,
    // that is by not rolling dice anymore :D
    static UPTO_6 : [usize; 7] = [1, 1, 2, 4, 8, 16, 32];

    // Base Case : If element is less than or equal to 6,
    // return corresponding value
    if amount <= 6 { return UPTO_6[amount]; }

    // Recursive Case : Else, return sum of all possible amounts,
    // That is, by throwing 1, 2, 3, 4, 5 and 6.
    return (
        dice_combinations(amount-1)+dice_combinations(amount-2)+
        dice_combinations(amount-3)+dice_combinations(amount-4)+
        dice_combinations(amount-5)+dice_combinations(amount-6)
    ) % 1_000_000_007;
}
```

With driver code

```rust
fn dice_combinations(amount :usize) -> usize{
    // We can make 0 in 1 and only 1 way,
    // that is by not rolling dice anymore :D
    static UPTO_6 : [usize; 7] = [1, 1, 2, 4, 8, 16, 32];

    // Base Case : If element is less than or equal to 6,
    // return corresponding value
    if amount <= 6 { return UPTO_6[amount]; }

    // Recursive Case : Else, return sum of all possible amounts,
    // That is, by throwing 1, 2, 3, 4, 5 and 6.
    return (
        dice_combinations(amount-1)+dice_combinations(amount-2)+
        dice_combinations(amount-3)+dice_combinations(amount-4)+
        dice_combinations(amount-5)+dice_combinations(amount-6)
    ) % 1_000_000_007;
}

// Driver Code
use std::io;

fn take_int() -> usize {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    return input.trim().parse().unwrap();
}

fn main() {
    let amount = take_int();
    println!("{}", dice_combinations(amount));
}
```


**Input**

> 7

**Output**

> 63

**Time Complexity : O( 2<sup>n</sup> )** <br/>
**Space Complexity : O( n )**

( Space complexity includes recursive stack space )

