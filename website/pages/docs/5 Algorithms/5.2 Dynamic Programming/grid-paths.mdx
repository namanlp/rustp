---
title: Grid Paths
section: 5.2 Dynamic Programming
order: 16
slug: /dynamic-programming/grid-paths/
description: Grid Paths.
---

# Grid Paths Problem
and Dynamic Programming Solution to it using memoization and tabulation in Rust Language.

## Introduction

Grid Paths is another Dynamic Problem based on grids.

In this problem, you are given a grid with traps / obstacles. You have to tell the number of unique paths to reach from top left to bottom right in the grid, **without stepping onto trap**.

You can only move in right and down directions.

This problem is taken from <a href = "https://cses.fi/problemset/task/1638" > CSES Problem Set </a>

In the grid, `.` denotes an empty cell, and `*` denotes a trap.

import gp from "../../../../images/Algorithms/grid-paths.webp"

<div style={{textAlign: 'center'}} >
    <img src={gp} width="100%" alt="Grid Paths" />
</div>

So, for above grid, answer is **22**


## Recursive Solution

In recursive solution, we start from the end, that is, bottom right cell, and take sum of paths of cell upwards and leftwards to it.

If the cell is `*` in the grid, we return 0.

### Algorithm

1. If the value of cell in grid is `*`, return 0.
2. Base Case would be that, if the current grid has 1 column and 1 row, return 1.
3. If current Grid has 1 row, we can traverse only leftwards. So, return Grid Paths of the left cell.
4. Similarly, If current Grid has 1 column, we can traverse only upwards. So, return Grid Paths of the upper cell.
5. Else, return the sum of Grid Paths of left and upper cells.


### Function

Here is the function using above algorithm

```rust

fn grid_paths(grid:&Vec<Vec<char>>, r:usize, c:usize) -> usize{
    // If there is no row or column in the grid, return 0
    if r<1 || c < 1 { return 0; }

    // If corresponding grid value is *, return 0
    if grid[r-1][c-1] == '*' { return 0;}

    // Base Case
    // If only 1 row and column, return 1
    if r == 1 && c==1 { return 1; }

    // Recursive Cases
    // If only 1 row, can go only left
    if r == 1 { return grid_paths(grid, 1, c-1); }

    // If only 1 column, can go only up
    if c == 1 { return grid_paths(grid, r-1, 1); }

    // Else, return sum of upper and left values
    return grid_paths(grid, r-1, c) + grid_paths(grid, r, c-1);
}
```
With Driver code

```rust


fn grid_paths(grid:&Vec<Vec<char>>, r:usize, c:usize) -> usize{
    // If there is no row or column in the grid, return 0
    if r<1 || c < 1 { return 0; }

    // If corresponding grid value is *, return 0
    if grid[r-1][c-1] == '*' { return 0;}

    // Base Case
    // If only 1 row and column, return 1
    if r == 1 && c==1 { return 1; }

    // Recursive Cases
    // If only 1 row, can go only left
    if r == 1 { return grid_paths(grid, 1, c-1); }

    // If only 1 column, can go only up
    if c == 1 { return grid_paths(grid, r-1, 1); }

    // Else, return sum of upper and left values
    return grid_paths(grid, r-1, c) + grid_paths(grid, r, c-1);
}

// Driver Code

fn main() {
    // Take the sample grid, as shown in picture
    let grid = vec![
        vec!['.', '.', '.', '.', '.'],
        vec!['.', '*', '.', '*', '.'],
        vec!['.', '.', '.', '.', '.'],
    ];

    // Print The number of paths of the grid
    println!("{}", grid_paths(&grid, grid.len(), grid[0].len()));
}
```

**Output**

> 3

**Time Complexity : O( 2<sup>r+c</sup> )** <br/>
**Space Complexity : O( r+c )**

( Space complexity includes recursive stack space )

