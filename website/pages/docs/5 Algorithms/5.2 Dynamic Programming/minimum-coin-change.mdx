---
title: Minimum Coin Change
section: 5.2 Dynamic Programming
order: 6
slug: /dynamic-programming/minimum-coin-change/
description: Minimum Coin Change
---

# Minimum Coin Change Problem
and space optimized Dynamic Programming Solution using tabulation and memoization in Rust Language.

## Introduction

Minimum Coin change is another classical Dynamic Programming problem and is very similar to [Coin Change Problem](/dynamic-programming/coin-change/).

In this problem, you are given coins of various denomination, and each coin has infinite supply.

You have to tell **Minimum number of coins** that you can use to make the exact amount.

**For Example :** If coins are [1, 3, 4] and the amount is 6, the answer should be **2**, because you can form the sum using coins [3, 3]

## Recursive Solution

Recursive solution to this problem is pretty straightforward. At each step, you have 2 choices :

1. **Exclude the given coin :** We can exclude the given coin and find the answer with the remaining coins. In this, we simply call recursion using same amount, but n-1 coins.
2. **Include the given coin :** We can include the coin and again call recursion by reducing amount, but on same number of coins, because we can include and exclude same coin again.

We have to take minimum of both the cases.

If amount is 0, we can form it using 0 coins.

Also, if n is 0 and amount is not 0, we can not make the money. Hence, return Infinite value. We will take 10<sup>10</sup> as our *infinite* value for this question.


### Function

Here is the function using above algorithm

```rust
use std::cmp::min;

fn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{

    let infinite = 10_000_000_000;
    // If amount is 0, we can make it without using coins
    if amount == 0 { return 0; }

    // If no coins left, but amount is not 0, we can not make the amount.
    // Hence, return infinite value
    if n==0 { return infinite; }

    // If current coin is greater than amount, we can not include it
    // Hence, compute recursively the coins of n-1
    if coins[n-1] > amount {
        return min_coin_change(coins, amount, n-1);
    }

    // Now we can either exclude or include current coin
    // If exclude, answer would be the min_coin_change of n-1 items
    // If include, answer would be reduce the amount by denomination
    // And calculate the min_coin_change of n items.
    // Because we can include the coin again

    // Return minimum of both cases.
    return min(min_coin_change(coins, amount, n-1),1+min_coin_change(coins, amount-coins[n-1], n));
}
```

With driver code

```rust
use std::cmp::min;

fn min_coin_change(coins:&Vec<usize>, amount : usize, n:usize) -> usize{

    let infinite = 10_000_000_000;
    // If amount is 0, we can make it without using coins
    if amount == 0 { return 0; }

    // If no coins left, but amount is not 0, we can not make the amount.
    // Hence, return infinite value
    if n==0 { return infinite; }

    // If current coin is greater than amount, we can not include it
    // Hence, compute recursively the coins of n-1
    if coins[n-1] > amount {
        return min_coin_change(coins, amount, n-1);
    }

    // Now we can either exclude or include current coin
    // If exclude, answer would be the min_coin_change of n-1 items
    // If include, answer would be reduce the amount by denomination
    // And calculate the min_coin_change of n items.
    // Because we can include the coin again

    // Return minimum of both cases.
    return min(min_coin_change(coins, amount, n-1),1+min_coin_change(coins, amount-coins[n-1], n));
}


// Driver Code

use std::io;
fn take_vector() -> Vec<usize> {
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let arr: Vec<usize> = input.trim().split_whitespace()
        .map(|x| x.parse().unwrap()).collect();
    return arr;
}

fn main() {
    let coins = take_vector();
    let amount = take_vector()[0];
    println!("{}", min_coin_change(&coins, amount, coins.len()));
}
```

**Input**

> 1 3 4 <br />
4

**Output**

> 6

**Time Complexity : O( 2<sup>n</sup> )** <br/>
**Space Complexity : O( n )**

( Space complexity includes recursive stack space )

## Overlapping Sub-problems

If we have a look carefully on recursive approach, we computed multiple results many times.

For example, if coins are [1, 2, 3, 6, 12] and amount is 24, the result for n = 2 and amount = 12 is calculated 4 times, and takes many recursions each time.
These are called overlapping sub-problems, because it is a sub-problem of actual problem and is overlapping in multiple recursions.

To prevent this, we can store the output and each result will be calculated only once.

In minimum coin change problem, we can create a dp matrix, and store each value by coin index and amount. That is, if we consider first `i` coins, the result will be stored at dp[i][amount].

This is called memoization or Top-down Dynamic Programming.

## Memoization ( Top-down DP ) Method

In memoization method, we simply take a DP matrix, and store the computed result.

### Algorithm

1. If the stored value for given number of coins and amount in DP matrix is not `None`, we return the value.
2. If the amount is 0, return 0 and if n is 0 and amount > 0, return infinity.
3. Else, use recursive logic to calculate the given value and store it in the DP matrix.
