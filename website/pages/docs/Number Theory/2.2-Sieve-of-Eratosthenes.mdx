---
title:  Sieve of Eratosthenes
section: 2.2 Factors of a Number
order: 23
slug: /number-theory/sieve-of-eratosthenes/
description: Sieve of Eratosthenes is very popular and useful algorithm, used for finding all the prime numbers upto a given number. We will discuss Sieve of Eratosthenes and write function to find all the primes upto a given number in Rust.
---

# Sieve of Eratosthenes
and program to find all the prime numbers upto a given number in Rust Language.

## Introduction

Sieve of Eratosthenes is one of the most efficient algorithm for finding all the prime numbers upto a given number.

It can print all the prime numbers upto a given number in **nearly linear time complexity** , O( N log(log( N ))) to be precise, and linear space complexity.

It also generates a complete list, which number upto N are primes and which are not. We can now check if a given number is prime or not in **constant time complexity !**

Sounds interesting? It is simple enough to understand also.

## Algorithm

In Sieve of Eratosthenes, we will be storing if a number is prime or not at the index. So, to check if 5 is prime, we just have to check for value at array[5], if it is true or false.

1. Initially, take a boolean array / vector of size n+1 and set initially every element to true. Now, set 0 and 1 to false ( Obviously number 0 and 1 are not prime numbers. )

import sieve1 from "../../../images/Number Theory/sieve/sieve-1.webp"

<div style={{textAlign: 'center'}} >
    <img src={sieve1} width="100%" alt="Initialize array for Sieve method" />
    *Initial Array*
</div>

2. Now, traverse from 2 to n, and if the number is marked as true, mark all its multiple as false. Because if obviously, a number is multiple of a number greater than or equal to 2, it is not prime.
Also, if a number is marked true, it must be prime because it was not marked as False by any smaller number. So, it is not a multiple of any smaller number, hence it is prime number.


import sieve2 from "../../../images/Number Theory/sieve/sieve-2.webp"

<div style={{textAlign: 'center'}} >
    <img src={sieve2} width="100%" alt="Mark multiples of 2 as false" />
    *After marking false all the multiples of 2*
</div>

3. If any number, say x,  is marked as false, there is no need to traverse through its multiples, because the multiples of x will be already be marked as false by the least prime number that divides x.

4. Repeat step 2 and 3 for all numbers upto n

5. After traversing all the numbers, we are left with a boolean array / vector in which the i index is set true, if number is prime, and false otherwise.

import sieve4 from "../../../images/Number Theory/sieve/sieve-4.webp"

<div style={{textAlign: 'center'}} >
    <img src={sieve4} width="100%" alt="Final Sieve Array" />
    *Final Array*
</div>

I hope you understood the Algorithm and liked it. Now, let us implement it.

## Program without optimization

Below is the basic implementation of Sieve of Eratosthenes.

```rust

fn sieve(n: usize) -> Vec<bool>{

    // Initialize Sieve Array with all elements initially set to True
    let mut sieve_array = vec![true; n+1];

    // Set arr[0] and arr[1] to false, because 0 and 1 are not prime
    sieve_array[0] =  false;
    sieve_array[1] = false;

    // Traverse from 2 to n
    // If a number is prime, mark all its multiples except number itself as false
    for i in 2..n+1 {
        if sieve_array[i] {

            // Mark all the multiples except number itself as false
            for j in (2*i..n+1).step_by(i) {
                sieve_array[j] = false;
            }
        }
    }

    return sieve_array;
}
```
Program With driver code

```rust
use std::io::stdin;

fn take_int() -> usize {
    let mut input = String::new();
    stdin().read_line(&mut input).unwrap();
    return input.trim().parse().unwrap();
}


fn sieve(n: usize) -> Vec<bool>{

    // Initialize Sieve Array with all elements initially set to True
    let mut sieve_array = vec![true; n+1];

    // Set arr[0] and arr[1] to false, because 0 and 1 are not prime
    sieve_array[0] =  false;
    sieve_array[1] = false;

    // Traverse from 2 to n
    // If a number is prime, mark all its multiples except number itself as false
    for i in 2..n+1 {
        if sieve_array[i] {

            // Mark all the multiples except number itself as false
            for j in (2*i..n+1).step_by(i) {
                sieve_array[j] = false;
            }
        }
    }

    return sieve_array;
}

// Driver Code
pub fn main() {
    // Take input and print all the numbers upto number
    // And tell if they are prime
    let number = take_int();

    // Generate a sieve array for the given number
    let sieve_array = sieve(number);

    // Output if the number is prime or not
    // We can now tell whether a number less than equal to N
    // is Prime or not in O( 1 ) or constant time complexity
    for i in 2..number+1 {
        if sieve_array[i] {
            println!("Yes, {}  is a prime number", i);
        }
        else {
            println!("No, {} is not a prime number", i);
        }
    }
}
```